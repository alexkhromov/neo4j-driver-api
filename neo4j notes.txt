https://www.ionos.com/community/markdown-migration/use-case-neo4j-vs-mysql/
- Graph databases are particularly useful for records which have a "many-to-many" relationship structure.

https://stackoverflow.com/questions/2541891/is-it-a-good-idea-to-use-mysql-and-neo4j-together

https://dzone.com/articles/mysql-vs-neo4j-large-scale

https://maxdemarzi.com/2017/02/06/neo4j-is-faster-than-mysql-in-performing-recursive-query/
https://github.com/maxdemarzi/distinct_network

FIRST OF ALL
https://graphaware.com/neo4j/2013/10/11/neo4j-bidirectional-relationships.html
https://community.neo4j.com/t/return-2nd-degree-connections/7741

- find friends of user friends who is not yet knows user:
neo4j:
	MATCH (a:Friend) - [:FRIEND_OF] - (b) - [:FRIEND_OF] - (c)
    WHERE a.name = 'Michelle1' and not (a) - [:FRIEND_OF] - (c)
    RETURN id(c) AS ID, c.name AS NAME
	//RETURN c
	or
	MATCH (a:Friend) - [:FRIEND_OF*2] - (c)
	WHERE a.name = 'Michelle1' and a <> c AND not (a) - [:FRIEND_OF] - (c)
	RETURN id(c) AS ID, c.name AS NAME
    //RETURN c
mysql:
	WITH GIVEN_ID AS (SELECT ID FROM FRIEND AS F WHERE F.NAME = 'Michelle1'),
    ALL_FRIENDS_IDS AS (
    	SELECT FS1.FRIEND_TO AS FRIEND_ID FROM FRIENDS AS FS1
        WHERE FS1.FRIEND_OF = (SELECT ID FROM GIVEN_ID)
    		UNION ALL
    	SELECT FS2.FRIEND_OF AS FRIEND_ID FROM FRIENDS AS FS2
        WHERE FS2.FRIEND_TO = (SELECT ID FROM GIVEN_ID)
    )
    SELECT F.* FROM (
    	SELECT DISTINCT FS1.FRIEND_TO AS FRIEND_ID FROM FRIENDS AS FS1
    	WHERE FS1.FRIEND_OF IN (SELECT * FROM ALL_FRIENDS_IDS)
    		UNION ALL
    	SELECT DISTINCT FS2.FRIEND_OF AS FRIEND_ID FROM FRIENDS AS FS2
    	WHERE FS2.FRIEND_TO IN (SELECT * FROM ALL_FRIENDS_IDS)
    ) AS ALL_FF_IDS LEFT JOIN FRIEND F ON F.ID = ALL_FF_IDS.FRIEND_ID
    WHERE FRIEND_ID NOT IN (SELECT * FROM ALL_FRIENDS_IDS)
    AND FRIEND_ID NOT IN (SELECT ID FROM GIVEN_ID)

- find user friends who friends only with user and user have more than 1 friend
neo4j:
	MATCH (a:Friend) - [:FRIEND_OF] - (b)
    WHERE size((a) -- ()) > 1 AND size((b) -- ()) = 1
    RETURN count(b) AS COUNT
    //RETURN a, b
    //RETURN id(a) AS FRIEND_OF_ID, id(b) AS FRIEND_TO_ID, a.name AS FRIEND_OF_NAME, b.name AS FRIEND_TO_NAME
mysql:
	WITH ALL_FRIENDS_COUNT AS (
		SELECT FRIEND_ID, SUM(COUNT) AS COUNT FROM (
			SELECT FS1.FRIEND_OF AS FRIEND_ID, COUNT(FS1.FRIEND_TO) AS COUNT FROM FRIENDS AS FS1
			GROUP BY FS1.FRIEND_OF
				UNION ALL
			SELECT FS2.FRIEND_TO AS FRIEND_ID, COUNT(FS2.FRIEND_OF) AS COUNT FROM FRIENDS AS FS2
			GROUP BY FS2.FRIEND_TO
	    ) AS ALL_FF_COUNT GROUP BY FRIEND_ID
	),
	FRIENDS_WITH_ONE_FRIEND AS (
		SELECT FRIEND_ID FROM ALL_FRIENDS_COUNT
	    WHERE COUNT = 1
	),
	FRIENDS_WITH_MORE_THAN_ONE_FRIEND AS (
		SELECT FRIEND_ID FROM ALL_FRIENDS_COUNT
	    WHERE COUNT > 1
	)
	SELECT COUNT(*) AS COUNT FROM FRIENDS FF
    -- SELECT FF.FRIEND_OF AS FRIEND_OF_ID, FF.FRIEND_TO AS FRIEND_TO_ID,
    -- F_OF.NAME AS FRIEND_OF_NAME, F_TO.NAME AS FRIEND_TO_NAME FROM FRIENDS FF
	INNER JOIN FRIEND AS F_OF ON F_OF.ID = FF.FRIEND_OF
	INNER JOIN FRIEND AS F_TO ON F_TO.ID = FF.FRIEND_TO
	WHERE
	(FF.FRIEND_OF IN (SELECT FRIEND_ID FROM FRIENDS_WITH_ONE_FRIEND)
	AND FF.FRIEND_TO IN (SELECT FRIEND_ID FROM FRIENDS_WITH_MORE_THAN_ONE_FRIEND))
	OR
	(FF.FRIEND_TO IN (SELECT FRIEND_ID FROM FRIENDS_WITH_ONE_FRIEND)
	AND FF.FRIEND_OF IN (SELECT FRIEND_ID FROM FRIENDS_WITH_MORE_THAN_ONE_FRIEND))